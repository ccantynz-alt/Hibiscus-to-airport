name: Auto-merge labeled PRs (guarded)

on:
  pull_request:
    types: [labeled, synchronize, reopened, ready_for_review]
  check_suite:
    types: [completed]
  workflow_run:
    workflows: ["Agent PR (Apply Patch -> PR)"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  automerge:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-merge if safe
        uses: actions/github-script@v7
        with:
          script: |
            // Guardrails:
            // - Only merge PRs labeled "auto-merge"
            // - Only if PR is mergeable and not draft
            // - Only if files changed do NOT include forbidden paths
            //
            // Forbidden paths (edit as needed):
            const FORBIDDEN = [
              ".vercel/",
              "vercel.json",
              ".github/workflows/",
              ".env",
              ".env.local",
              "package.json",
              "package-lock.json",
              "npm-shrinkwrap.json"
            ];

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Identify PR context if available
            let prNumber = null;
            if (context.payload.pull_request) prNumber = context.payload.pull_request.number;

            if (!prNumber) {
              core.info("No direct PR context; skipping (this workflow also triggers on check_suite/workflow_run).");
              return;
            }

            const pr = (await github.rest.pulls.get({ owner, repo, pull_number: prNumber })).data;

            if (pr.draft) { core.info("PR is draft. Not merging."); return; }

            const labels = pr.labels.map(l => l.name);
            if (!labels.includes("auto-merge")) { core.info("No auto-merge label. Not merging."); return; }

            // Ensure mergeable state
            if (pr.mergeable === false) { core.info("PR not mergeable."); return; }

            // Check changed files for forbidden paths
            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: prNumber, per_page: 100 });
            const bad = [];
            for (const f of files) {
              for (const p of FORBIDDEN) {
                if (f.filename === p || f.filename.startsWith(p)) bad.push(f.filename);
              }
            }
            if (bad.length) {
              core.setFailed("Auto-merge blocked due to forbidden file changes:\n" + bad.join("\n"));
              return;
            }

            // Enable auto-merge (requires repo setting to allow it)
            try {
              await github.rest.pulls.enableAutoMerge({
                owner, repo, pull_number: prNumber,
                merge_method: "squash"
              });
              core.info(`Enabled auto-merge for PR #${prNumber}`);
            } catch (e) {
              core.setFailed("Failed to enable auto-merge. Ensure repo allows auto-merge. Error: " + e.message);
            }